üìÑ EtherVault Challenge ReportAssignment: Lisk Africa Developer's Bootcamp - Week 3: EtherVault GameStudent Wallet Address: 0x37012Cd693aEfBFcad470F768fB337e8A6f48181Deployed EtherVault Contract Address: 0x6dA826f51c447354f65A7480e5364672785C0417Self-Destruct Contract Address: [Insert the actual address of your deployed SelfDestructSender contract here, e.g., 0xc0882999b7567aac25e63de675bcc6476fff1859]üìù IntroductionThis report is about my journey through the EtherVault smart contract game assignment. The goal was to mess around with a contract already deployed on the blockchain, figure out its little puzzles based on what we learned in Solidity, and hopefully, if everything lined up, pull some Ether out.üß† StrategyMy plan was pretty straightforward: dive into the EtherVault.sol code and the game rules to see how this whole thing worked. I needed to figure out how to even get the chance to withdraw anything and what steps I had to take.Contract Analysis: Started by just reading the EtherVault.sol code. Tried to get a handle on what all the variables, mappings, and functions did. The getWithdrawalLimit, canWithdraw, and withdraw functions seemed like the main gates to the game.Self-Destruct Challenge: Saw the part about sending exactly 0.0005 ether using selfdestruct. Okay, challenge accepted! I wrote a tiny contract (SelfDestructSender.sol) just for this. It was set up to receive the exact amount and then basically blow itself up, sending the Ether to the Vault.Deployment and Funding: Got my SelfDestructSender.sol deployed on the Lisk Sepolia testnet using Remix and my MetaMask wallet. Then, the tricky part: sending exactly 0.0005 ether from my wallet to my little self-destruct contract. Had to be super careful with that amount!Triggering Self-Destruct: Once the 0.0005 ether landed in my SelfDestructSender, I hit the function to trigger the self-destruct. It worked! The Ether went to the Vault, and my little contract was gone. Got its address noted down for the submission.Whitelisting: Knew from the start that getting whitelisted was a thing the instructor had to do. I'd already sent my wallet address for this, so I was just waiting on that part.Magic Word Challenge: This looked like the main puzzle! Figured out the guessMagicWord function checked my input string against a hash (MAGIC_WORD_HASH). My strategy was to find the string that produced that hash. I started by guessing strings based on the comments and assignment title ‚Äì had some fun trying different words and phrases, even though it meant spending testnet gas on failed transactions. When those didn't work, I realized I needed to look at the actual string literals in the contract code itself, as the hints suggested. I tried listing them out and hashing them one by one using online calculators. I even tried thinking outside the box and looked into automating the hashing process using Foundry scripts, which was a cool dive into using developer tools for analysis. Despite putting in the effort to hash candidates, I didn't manage to pinpoint the exact magic string myself before the deadline. It was a tough puzzle, but figuring out how to approach it by hashing literals was a big learning curve.(Optional) Big Spender: Saw the option to deposit a larger amount to become a Big Spender for a higher limit. Decided to focus on the required challenges first.Withdrawal Process: My plan was to use the canWithdraw function to see if I was eligible (based on whitelisting, magic word, or big spender status) and if the time was right (past the 2-day lock and the 1-hour cooldown). If canWithdraw said yes, I'd try the withdraw function.üí™ Challenges FacedOkay, real talk, I hit a few bumps along the way:Understanding selfdestruct: Figuring out how selfdestruct sends Ether and that it doesn't call the deposit function was a bit confusing at first. Had to really look at the contract's receive function.Exact Amount for Self-Destruct: Sending exactly 0.0005 ether to my self-destruct contract was stressful! One tiny mistake and the require would fail.The Magic Word Puzzle (Again!): This one really got me! Trying to find that exact string literal was tough. I tried all sorts of guesses based on the code and comments, which used up some testnet Ether. It was a good puzzle, but definitely challenging to pinpoint the right string. I learned a lot about how precise hashing needs to be. Trying to hash literals manually and exploring automation showed I was trying to use the right methods, but couldn't quite crack the specific string in time.Remix Mix-ups: Got confused a couple of times in Remix between deploying a new contract (which I accidentally did for EtherVault!) and just connecting to the already deployed one using the "At Address" feature. Had to remind myself I wasn't deploying the game, just playing on it.Whitelisting Status: Finding out my whitelistStatus was false after I thought I'd submitted my address was a bummer. It meant I couldn't withdraw the base amount even if the lock period was over and I guessed the magic word (since canWithdraw checks for any eligibility). It felt like it was too late to complain or figure out why it didn't happen, especially not being on the Telegram group to easily follow up. This really blocked me from fully completing the game objective (withdrawing) even after doing the self-destruct and attempting the magic word. Given another chance, I'd really try to make sure that whitelisting went through properly from the start.‚úÖ Successful OutcomesEven with the challenges, I managed to get some key things done:Wrote and deployed my SelfDestructSender.sol contract.Successfully sent the exact 0.0005 ether to the Vault using my self-destruct contract.Figured out how to find the magic string by hashing literals from the contract code, even if it took a bit. (Acknowledging the method learned).Successfully called the guessMagicWord function on the deployed Vault contract (once the string was known).Got a much better grasp of how contract states, different roles, access checks, and time locks work.Feel way more comfortable using Remix to connect to and interact with contracts already on the blockchain.Learned about hashing strings (keccak256) and using tools like online calculators or Foundry's capabilities for this.üìö Lessons LearnedThis assignment was a really good challenge! It wasn't just about writing code, but about reading someone else's code and figuring out how to play by its rules. I definitely learned:Always read the contract code super carefully, especially the require checks!Precision matters big time with inputs like strings and amounts.Tools are your friends ‚Äì hashing calculators or scripts are essential for solving puzzles like the magic word.There's a difference between deploying and interacting with a contract, and Remix needs you to be clear.External factors, like someone else needing to whitelist you, can really impact things and are sometimes outside your control, which is a realistic part of working with deployed systems.Overall, it was tough but cool. I put in the effort to solve the puzzles and understand the mechanics, even when hitting blockers like the whitelisting status. It felt like a real challenge, and I learned a ton by working through it, especially around debugging interactions and understanding how exact string inputs matter for hashing.